<!doctype HTML>
<html>
  <head> 
    <script src="lib/gl-matrix-min.js"></script>
    <script src="thing.js"></script>
    <script src="quad.js"></script>
    <script src="grid.js"></script>
    <script src="glyphgrid.js"></script>
    <script src="rendertext.js"></script>
    <script src="renderer.js"></script>
    <script src="main.js"></script>
  </head>
  <body style="margin: 0;">
    <canvas id="canvas" width="600" height="300" style="width: 600px; height: 300px; border: 1px solid black;"></canvas>
    <br/> 
    <input id="str" type="text"></input>
  </body>
  <script id="thing-vs" type="x-shader/x-vertex">#version 300 es

    uniform mat4 u_worldViewProjection;
    uniform mat4 u_world;
    uniform vec3 u_offset;

		in vec2 a_uv;
		in vec4 a_position;
	  in vec3 a_normal;

		out vec2 v_uv;
	  out vec3 v_normal;

		void main() {
     	v_uv = a_uv; 
     	v_normal = mat3(u_world) * a_normal; 
			gl_Position = u_worldViewProjection * a_position;
			gl_Position.xyz += u_offset;
  	}
  </script>
  <script id="thing-fs" type="x-shader/x-fragment">#version 300 es

		precision mediump float;
   
	 	in vec2 v_uv;
	 	in vec3 v_normal;

		uniform sampler2D u_image;
    uniform vec3 u_light;
	
    out vec4 outColor;
		
    void main() {
      float light = min(max(dot(normalize(v_normal), u_light) + 0.8, 0.4), 0.9);
			outColor = texture(u_image, v_uv);
      outColor.rgb *= light;
  	}
  </script>
  <script id="glyph-grid-vs" type="x-shader/x-vertex">#version 300 es
  
		in vec2 a_position;
		in vec2 a_uv;
		in vec2 a_offset;
		
    uniform vec2 u_resolution;
    uniform vec2 u_scale;
		
    out vec2 v_uv;
		
		void main() {
    	v_uv = a_uv;
    	vec2 aspected = vec2(a_position.x / u_resolution.x, a_position.y / u_resolution.y) * u_resolution.x;
    	gl_Position = vec4((u_scale * aspected) + a_offset, 0, 1);
  	}
  </script>
  <script id="glyph-grid-fs" type="x-shader/x-fragment">#version 300 es

		precision mediump float;
		
    in vec2 v_uv;
    
    uniform sampler2D u_image;
		 
    out vec4 outColor;
		
    void main() {
			outColor = vec4(0.3, 1, 0.3, 1) * texture(u_image, v_uv);
  	}
  </script>
  <script id="text-quad-vs" type="x-shader/x-vertex">#version 300 es
  
		in vec2 a_position;
		in vec2 a_uv;
		
    uniform vec2 u_resolution;
		
    out vec2 v_uv;
		
		void main() {
    	v_uv = a_uv;
    	gl_Position = vec4(a_position, 0, 1);
  	}
  </script>
  <script id="text-quad-fs" type="x-shader/x-fragment">#version 300 es
 		
		precision mediump float;
		
		uniform sampler2D u_image;
    uniform float u_time;

		in vec2 v_uv;
    out vec4 outColor;

		void main() {
			vec4 sum = vec4(0.0);

			//our original texcoord for this fragment
			vec2 tc = v_uv;

			float blur = 0.003; 

			//the direction of our blur
			//(1.0, 0.0) -> x-axis blur
			//(0.0, 1.0) -> y-axis blur
			float hstep = 0.9;
			float vstep = 0.9;

			//apply blurring, using a 9-tap filter with predefined gaussian weights

			sum += texture(u_image, vec2(tc.x - 4.0*blur*hstep, tc.y - 4.0*blur*vstep)) * 0.0162162162;
			sum += texture(u_image, vec2(tc.x - 3.0*blur*hstep, tc.y - 3.0*blur*vstep)) * 0.0540540541;
			sum += texture(u_image, vec2(tc.x - 2.0*blur*hstep, tc.y - 2.0*blur*vstep)) * 0.1216216216;
			sum += texture(u_image, vec2(tc.x - 1.0*blur*hstep, tc.y - 1.0*blur*vstep)) * 0.1945945946;

			sum += texture(u_image, vec2(tc.x, tc.y)) * 0.2270270270;

			sum += texture(u_image, vec2(tc.x + 1.0*blur*hstep, tc.y + 1.0*blur*vstep)) * 0.1945945946;
			sum += texture(u_image, vec2(tc.x + 2.0*blur*hstep, tc.y + 2.0*blur*vstep)) * 0.1216216216;
			sum += texture(u_image, vec2(tc.x + 3.0*blur*hstep, tc.y + 3.0*blur*vstep)) * 0.0540540541;
			sum += texture(u_image, vec2(tc.x + 4.0*blur*hstep, tc.y + 4.0*blur*vstep)) * 0.0162162162;

      // apply some slight pulsing to the text
			outColor = vec4(sum.rgb, 0.85 + (sin(u_time / 20.0) * 0.15));
		}	
  </script>
</html>
